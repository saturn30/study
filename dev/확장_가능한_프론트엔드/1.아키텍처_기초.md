# 1. 아키텍처 기초

[https://blog.codeminer42.com/scalable-frontend-1-architecture-9b80a16b8ec7/](https://blog.codeminer42.com/scalable-frontend-1-architecture-9b80a16b8ec7/)

소프트웨어 개발과 관련하여 확장성이라는 단어의 가장 일반적인 두 의미는 코드 베이스의 성능 및 유지관리 가능성과 관련 있다. 성능보다 유지관리 용이성에 초점을 맞추면 나머지 애플리케이션에 영향을 주지 않고 성능을 더 쉽게 조정할 수 있다.

### 소프트웨어 아키텍처란 무엇인가?

아키텍처는 소프트웨어 단위가 서로 상호 작용하여 내려야 할 가장 중요한 결정을 강조하고 2차 결정과 구현 세부사항을 연기하는 방법이다. ??

소프트웨어 아키텍처를 설계한다는 것은 지원 기술에서 실제 애플리케이션을 분리하는 것을 의미한다. 실제 애플리케이션은 db, ajax 요청 또는 gui에 대해 알지 못한다. 대신 사용 사례를 실행하는 행위자나 데이터가 유지되는 위치에 관계없이 소프트웨어에서 다루는 개념을 나타내는 사용 사례 및 도메인 단위로 구성된다.

아키텍처는 파일 구성을 의미하는 것도 아니고 파일과 폴더의 이름을 지정하는 방법도 아니다.

### 프런트엔드 개발의 레이어

중요한 것과 부차적인 것을 구분하는 방법 중 하나는 특정한 책임을 가진 레이어들로 나누는 것이다. 레이어 기반 아키텍처의 일반적인 접근 방식은 애플리케이션, 도메인, 인프라 및 입력의 4가지 레이어로 분리하는 것이다. 자세한 건 [이 글](https://blog.codeminer42.com/nodejs-and-good-practices-354e7d763626/)을 보세요. [NodeJS 및 레이어 모범사례](https://www.notion.so/NodeJS-c67191f6ea9943a1bd119700680072d7)

도메인 및 애플리케이션 계층은 기술에 구애받지 않기 때문에 프런트엔드와 백엔드 간에 크게 다르지 않지만 입력 및 인프라 계층은 다름. 웹 브라우저에서 입력 레이어인 뷰에 단일 액터가 있는 것이 일반적으로 이를 뷰 레이어라고 부를 수 있다. 또한 프런트엔드는 데이터베이스나 대기열 엔진에 액세스할 수 없으므로 이 부분은 인프라 계층에 생략됨. 대신 ajax 요청, 쿠키, 로컬 스토리지 등의 단위를 캡슐화하는 추상화를 인프라 계층에 포함시킬 수 있음. 주요한 차이점은 추상화되는 것뿐이므로 프런트엔드도 레포지토리를 가질 수 있음. 동일한 인터페이스를 사용하지만 그 아래 다른 기술이 들어갈 수 있다.

뷰를 생성하기 위해 리액트, 뷰, 앵귤러 등 뭘 사용하든 상관없음. 프런트 레이어 기반 아키텍처는 입력/뷰 계층을 항상 로컬 상태와 동기화하도록 유지하려면 단방향 데이터 흐름을 따라야 한다. 다섯 번째 레이어인 상태 레이어가 필요할 수 있음.

### 상태 레이어

단방향 데이터 흐름을 따를 때 뷰 내부에서 직접 수신한 데이터를 변경하지 않는다. 대신 액션이라고 하는 것을 전달함.

이 계층은 백엔드에서 가져온 데이터, 프런트에서 생성되었지만 지속 도지 않는 임시 데이터나 요청 상태와 같은 일시적인 정보와 같이 프런트엔드의 로커 상태를 관리하는 역할을 한다.

보통 액션에서 비즈니스 로직이나 유즈 케이스를 작성하는 게 일반적이지만 다른 레이어의 설명을 주의 깊게 읽으면 이미 다른 더 적합한 레이어가 있음을 알 수 있다. 액션이 컨트롤러와 유사함. 애플리케이션 레이어에서 수행하라는 듯?

복잡한 로직이나 직접적인 ajax 호출은 다른 계층의 책임이기 때문에 상태 계층은 로컬 저장소를 관리하는 방법만 알고 있으면 된다.

### 의존성 주입

레이어는 어떻게 대화해야 하나? 레이어를 연결하지 않고 레이어가 다른 레이어에 의존하도록 하려면 의존성 주입을 사용해야 함.

우리는 리액트/리덕스 연결을 통해 뷰와 상태 계층 사이에 의존성 주입을 달성한다. 그러나 우리는 또한 액션이 비즈니스 로직을 유스 케이스에 위임한다고 했다. 그렇다면 유즈케이스(애플리케이션 레이어)를 액션(상태 레이어)에 어떻게 주입하는가?

뷰 레이어에 상태 레이어가 주입되고 상태 레이어에 애플리케이션 레이어가 주입된다.

```jsx
const userRepository = makeUserRepository({
  api
});

const getArticle = makeGetArticle({
  userRepository,
  articleRepository
});

---

const makeGetArticle = ({ validateUser, userRepository }) => async (userData) => {
  if(!validateUser(userData)) {
    throw new Error('Invalid user');
  }

  try {
    const user = await userRepository.add(userData);
    return user;
  } catch(error) {
    throw error;
  }
};

---

const makeUserRepository = ({ api }) => ({
  async add(userData) {
    const user = await api.post('/users', userData);

    return user;
  }
});
```

getArticle이 유즈케이스인듯
